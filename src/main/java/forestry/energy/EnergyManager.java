package forestry.energy;

import net.minecraft.nbt.CompoundNBT;
import net.minecraft.util.math.MathHelper;

import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.util.LazyOptional;
import net.minecraftforge.energy.CapabilityEnergy;
import net.minecraftforge.energy.EnergyStorage;
import net.minecraftforge.energy.IEnergyStorage;

import forestry.api.core.INbtReadable;
import forestry.api.core.INbtWritable;
import forestry.core.config.Config;
import forestry.core.network.IStreamable;
import forestry.core.network.PacketBufferForestry;
import forestry.energy.compat.EnergyStorageWrapper;
import forestry.energy.compat.mj.MjHelper;
import forestry.energy.compat.tesla.TeslaHelper;

//import buildcraft.api.mj.IMjConnector;
//import buildcraft.api.mj.IMjPassiveProvider;
//import buildcraft.api.mj.IMjReadable;
//import buildcraft.api.mj.IMjReceiver;
//import buildcraft.api.mj.IMjRedstoneReceiver;
//import net.darkhax.tesla.api.ITeslaConsumer;
//import net.darkhax.tesla.api.ITeslaHolder;
//import net.darkhax.tesla.api.ITeslaProducer;

public class EnergyManager extends EnergyStorage implements IStreamable, INbtReadable, INbtWritable {
    private EnergyTransferMode externalMode = EnergyTransferMode.BOTH;

    public EnergyManager(int maxTransfer, int capacity) {
        super(EnergyHelper.scaleForDifficulty(capacity), EnergyHelper.scaleForDifficulty(maxTransfer), EnergyHelper.scaleForDifficulty(maxTransfer));
    }

    public void setExternalMode(EnergyTransferMode externalMode) {
        this.externalMode = externalMode;
    }

    public EnergyTransferMode getExternalMode() {
        return externalMode;
    }

    @Override
    public void read(CompoundNBT nbt) {
        final int energy;
        if (nbt.contains("EnergyManager")) { // legacy
            CompoundNBT energyManagerNBT = nbt.getCompound("EnergyManager");
            CompoundNBT energyStorageNBT = energyManagerNBT.getCompound("EnergyStorage");
            energy = energyStorageNBT.getInt("Energy");
        } else {
            energy = nbt.getInt("Energy");
        }

        setEnergyStored(energy);
    }

    @Override
    public CompoundNBT write(CompoundNBT nbt) {
        nbt.putInt("Energy", energy);
        return nbt;
    }

    @Override
    public void writeData(PacketBufferForestry data) {
        data.writeVarInt(this.energy);
    }

    @Override
    public void readData(PacketBufferForestry data) {
        int energyStored = data.readVarInt();
        setEnergyStored(energyStored);
    }

    public int getMaxEnergyReceived() {
        return this.maxReceive;
    }

    /**
     * Drains an amount of energy, due to decay from lack of work or other factors
     */
    public void drainEnergy(int amount) {
        setEnergyStored(energy - amount);
    }

    /**
     * Creates an amount of energy, generated by engines
     */
    public void generateEnergy(int amount) {
        setEnergyStored(energy + amount);
    }

    public void setEnergyStored(int energyStored) {
        this.energy = energyStored;
        if (this.energy > capacity) {
            this.energy = capacity;
        } else if (this.energy < 0) {
            this.energy = 0;
        }
    }

    public boolean hasCapability(Capability<?> capability) {
        return Config.enableRF && capability == CapabilityEnergy.ENERGY ||
                Config.enableTesla && hasTeslaCapability(capability) ||
                Config.enableMJ && hasMjCapability(capability);
    }

    private boolean hasTeslaCapability(Capability<?> capability) {
        return false;
        //		return capability == TeslaHelper.TESLA_PRODUCER && externalMode.canExtract() ||
        //			capability == TeslaHelper.TESLA_CONSUMER && externalMode.canReceive() ||
        //			capability == TeslaHelper.TESLA_HOLDER;
    }

    private boolean hasMjCapability(Capability<?> capability) {
        return false;//capability == MjHelper.CAP_READABLE ||
        //			capability == MjHelper.CAP_CONNECTOR ||
        //			capability == MjHelper.CAP_PASSIVE_PROVIDER && externalMode.canExtract() ||
        //			capability == MjHelper.CAP_REDSTONE_RECEIVER && externalMode.canReceive() ||
        //			capability == MjHelper.CAP_RECEIVER && externalMode.canReceive();
    }

    public <T> LazyOptional<T> getCapability(Capability<T> capability) {
        if (!hasCapability(capability)) {
            return LazyOptional.empty();
        }
        if (capability == CapabilityEnergy.ENERGY) {
            IEnergyStorage energyStorage = new EnergyStorageWrapper(this, externalMode);
            return LazyOptional.of(() -> energyStorage).cast();
        } else if (TeslaHelper.isTeslaCapability(capability)) {
            //			Capability<ITeslaProducer> teslaProducer = TeslaHelper.TESLA_PRODUCER;
            //			Capability<ITeslaConsumer> teslaConsumer = TeslaHelper.TESLA_CONSUMER;
            //			Capability<ITeslaHolder> teslaHolder = TeslaHelper.TESLA_HOLDER;
            //
            //			if (capability == teslaProducer && externalMode.canExtract()) {
            //				return teslaProducer.cast(new TeslaProducerWrapper(this));
            //			} else if (capability == teslaConsumer && externalMode.canReceive()) {
            //				return teslaConsumer.cast(new TeslaConsumerWrapper(this));
            //			} else if (capability == teslaHolder) {
            //				return teslaHolder.cast(new TeslaHolderWrapper(this));
            //			}
        } else if (MjHelper.isMjCapability(capability)) {
            //			Capability<IMjConnector> mjConnector = MjHelper.CAP_CONNECTOR;
            //			Capability<IMjPassiveProvider> mjPassiveProvider = MjHelper.CAP_PASSIVE_PROVIDER;
            //			Capability<IMjReadable> mjReadable = MjHelper.CAP_READABLE;
            //			Capability<IMjReceiver> mjReceiver = MjHelper.CAP_RECEIVER;
            //			Capability<IMjRedstoneReceiver> mjRedstoneReceiver = MjHelper.CAP_REDSTONE_RECEIVER;
            //
            //			if (capability == mjPassiveProvider && externalMode.canExtract()) {
            //				return mjPassiveProvider.cast(new MjPassiveProviderWrapper(this));
            //			} else if (capability == mjReceiver && externalMode.canReceive()) {
            //				return mjReceiver.cast(new MjReceiverWrapper(this));
            //			} else if (capability == mjRedstoneReceiver && externalMode.canReceive()) {
            //				return mjRedstoneReceiver.cast(new MjRedstoneReceiverWrapper(this));
            //			} else if (capability == mjReadable) {
            //				return mjReadable.cast(new MjReadableWrapper(this));
            //			} else if (capability == mjConnector) {
            //				return mjConnector.cast(new MjConnectorWrapper(this));
            //			}
        }
        return LazyOptional.empty();
    }

    public int calculateRedstone() {
        return MathHelper.floor(((float) energy / (float) capacity) * 14.0F) + (energy > 0 ? 1 : 0);
    }

}
